THEORY ProofList IS
_f(1) & _f(2) & _f(8) & _f(16) & WellDefinedness_swap.3,(_f(22) => _f(30));
_f(1) & _f(2) & _f(8) & _f(16) & WellDefinedness_swap.2,(_f(22) => _f(31));
_f(1) & _f(2) & _f(8) & _f(16) & WellDefinedness_swap.1,(_f(22) => _f(43));
_f(1) & _f(2) & _f(8) & _f(15) & WellDefinedness_totalguests.3,(_f(33) & _f(22) => _f(31));
_f(1) & _f(2) & _f(8) & _f(15) & WellDefinedness_totalguests.2,(_f(33) & _f(22) => _f(35));
_f(1) & _f(2) & _f(8) & _f(15) & WellDefinedness_totalguests.1,(_f(22) => _f(34));
_f(1) & _f(2) & _f(8) & _f(15) & WellDefinedness_vacancies.1,(_f(22) => _f(32));
_f(1) & _f(2) & _f(8) & _f(12) & WellDefinedness_roomquery.2,(_f(22) => _f(31));
_f(1) & _f(2) & _f(8) & _f(12) & WellDefinedness_roomquery.1,(_f(22) => _f(30));
_f(1) & _f(2) & _f(8) & WellDefinedness_Precondition_checkin.2,(_f(12) & _f(29) & _f(22) => _f(31));
_f(1) & _f(2) & _f(8) & WellDefinedness_Precondition_checkin.1,(_f(12) & _f(29) & _f(22) => _f(30));
_f(1) & _f(19) & WellDefinednessProperties.1,(_f(21) & _f(22) => _f(23));
_f(1) & _f(2) & _f(8) & _f(16) & swap.2,(_f(3) & _f(6) => _f(18));
_f(1) & _f(2) & _f(8) & _f(16) & swap.1,(_f(3) & _f(4) => _f(17));
_f(1) & _f(2) & _f(8) & _f(12) & checkout.2,(_f(3) & _f(6) => _f(14));
_f(1) & _f(2) & _f(8) & _f(12) & checkout.1,(_f(3) & _f(4) => _f(13));
_f(1) & _f(2) & _f(8) & _f(9) & checkin.2,(_f(3) & _f(6) => _f(11));
_f(1) & _f(2) & _f(8) & _f(9) & checkin.1,(_f(3) & _f(4) => _f(10));
_f(1) & _f(2) & Initialisation.2,(_f(3) & _f(6) => _f(7));
_f(1) & _f(2) & Initialisation.1,(_f(3) & _f(4) => _f(5))
END
&
THEORY Formulas IS
((NAT) = (((0) .. (2147483647)))) & ((INT) = (((-2147483647) .. (2147483647))));
ROOM: FIN(INTEGER) & not(ROOM = {}) & ((sze) : ((NATURAL-{0}))) & ((card(ROOM)) = (sze)) & small : POW( ROOM);
"Invariant is preserved";
"Check invariant ((numbers) : (((ROOM) --> (((0) .. (6))))))";
(((ROOM * ({0}))) : (((ROOM) --> (((0) .. (6))))));
"Check invariant (numbers )[small] : POW( ((0) .. (4)))";
((ROOM * ({0})) )[small] : POW( ((0) .. (4)));
numbers : ROOM +-> ((0) .. (6)) & dom(numbers) = ROOM & ((numbers) : (((ROOM) --> (((0) .. (6)))))) & (numbers )[small] : POW( ((0) .. (4)));
((rr) : (ROOM)) & ((nn) : (((1) .. (6)))) & (((numbers )(rr)) = (0)) & ((((rr) : (small))) => ((nn <= 4)));
((((numbers) <+ (({((rr) |-> (nn))})))) : (((ROOM) --> (((0) .. (6))))));
(((numbers) <+ (({((rr) |-> (nn))}))) )[small] : POW( ((0) .. (4)));
((rr) : (ROOM));
((((numbers) <+ (({((rr) |-> (0))})))) : (((ROOM) --> (((0) .. (6))))));
(((numbers) <+ (({((rr) |-> (0))}))) )[small] : POW( ((0) .. (4)));
btrue;
((rr) : (ROOM)) & ((ss) : (ROOM)) & !(xx).(((((xx) : (ROOM)) & ((xx) = (rr))) => (not(((rr) = (ss)))))) & ((((rr) : (small))) => (((numbers )(ss) <= 4))) & ((((ss) : (small))) => (((numbers )(rr) <= 4)));
((((numbers) <+ (({((rr) |-> ((numbers )(ss)))}\/{((ss) |-> ((numbers )(rr)))})))) : (((ROOM) --> (((0) .. (6))))));
(((numbers) <+ (({((rr) |-> ((numbers )(ss)))}\/{((ss) |-> ((numbers )(rr)))}))) )[small] : POW( ((0) .. (4)));
ROOM: FIN(INTEGER) & not(ROOM = {});
((card(ROOM)) = (sze));
((sze) : ((NATURAL-{0})));
"Well definedness";
((ROOM) : (FIN(ROOM)));
numbers : ROOM +-> ((0) .. (6));
dom(numbers) = ROOM;
((numbers) : (((ROOM) --> (((0) .. (6))))));
((((rr) : (small))) => (btrue));
(((numbers )(rr)) = (0));
((nn) : (((1) .. (6))));
((rr) : (dom(numbers)));
((numbers) : (((dom(numbers)) +-> (ran(numbers)))));
((((numbers) |> (({0})))) : (FIN(((numbers) |> (({0}))))));
((zz) : (ROOM));
((SET(zz).(((zz) : (ROOM)))) : (FIN(SET(zz).(((zz) : (ROOM))))));
((zz) : (dom(numbers)));
((((xx) : (ROOM))) => (btrue));
((((xx) : (ROOM)) & ((xx) = (rr))) => (btrue));
((((rr) : (small))) => (((ss) : (dom(numbers))) & ((numbers) : (((dom(numbers)) +-> (ran(numbers)))))));
((((ss) : (small))) => (((rr) : (dom(numbers))) & ((numbers) : (((dom(numbers)) +-> (ran(numbers)))))));
((((rr) : (small))) => (((numbers )(ss) <= 4)));
!(xx).(((((xx) : (ROOM)) & ((xx) = (rr))) => (not(((rr) = (ss))))));
((ss) : (ROOM));
((ss) : (dom(numbers)))
END
&
THEORY EnumerateX
END
